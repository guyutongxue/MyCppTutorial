[
  {
    "keyword": "alignas",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šæŒ‡ç¤ºç±»å‹çš„å¯¹é½è¦æ±‚ï¼ˆåªèƒ½æ›´ä¸¥æ ¼ï¼‰ã€‚</p>",
        "sdsc": [
          "<x-or>struct<hr>class</x-or> alignas(<i>è¡¨è¾¾å¼</i>) <b>ç±»å</b> {\n    <b>æˆå‘˜åˆ—è¡¨</b>\n};",
          "<x-or>struct<hr>class</x-or> alignas(<i>ç±»å‹</i>) <b>ç±»å</b> {\n    <b>æˆå‘˜åˆ—è¡¨</b>\n};"
        ],
        "example": "struct alignas(8) S {\n    char m;\n};\nstruct alignas(int) S {\n    char m;\n};"
      }
    ]
  },
  {
    "keyword": "alignof",
    "usage": [
      {
        "info": "ç”¨äºè¿ç®—ç¬¦ï¼šæŸ¥è¯¢ç±»å‹çš„å¯¹é½è¦æ±‚ã€‚C++ è¦æ±‚ä»»ä½•ç±»å‹å¿…é¡»å¯¹é½åˆ°å†…å­˜ä¸­2çš„æ•´æ•°æ¬¡å¹‚ä¸ªå­—èŠ‚æ•°ã€‚",
        "sdsc": [
          "alignof(<i>ç±»å‹</i>)"
        ],
        "example": "struct S {\n    char c;\n    int i;\n};\nint main() {\n    alignof(char); //1\n    alignof(S); // 4 maybe\n}"
      }
    ]
  },
  {
    "keyword": "and",
    "usage": [
      {
        "info": "ç”¨äºè¿ç®—ç¬¦ï¼š<code>&amp;&amp;</code> çš„æ›¿ä»£å†™æ³•ã€‚",
        "sdsc": [
          "<i>å·¦ä¾§æ“ä½œæ•°</i> and <i>å³ä¾§æ“ä½œæ•°</i>"
        ],
        "example": "x > 0 and x < 5;"
      }
    ]
  },
  {
    "keyword": "and_eq",
    "usage": [
      {
        "info": "ç”¨äºè¿ç®—ç¬¦ï¼š<code>&amp;=</code> çš„æ›¿ä»£å†™æ³•ã€‚",
        "sdsc": [
          "<i>å·¦ä¾§æ“ä½œæ•°</i> and_eq <i>å³ä¾§æ“ä½œæ•°</i>"
        ],
        "example": "x and_eq (1 << i);"
      }
    ]
  },
  {
    "keyword": "asm",
    "usage": [
      {
        "info": "å…¶å®ƒï¼šåµŒå…¥æ±‡ç¼–è¯­è¨€ã€‚å¯¹äºä¸åŒç¼–è¯‘ç¯å¢ƒè§„åˆ™ä¸åŒã€‚",
        "sdsc": [
          "asm(<i>å­—ç¬¦ä¸²å­—é¢é‡</i>)"
        ],
        "example": "// exit in Linux\nasm (\"movq $60, %rax\\n\\t\"\n     \"movq $0,  %rdi\\n\\t\"\n     \"syscall\");"
      }
    ]
  },
  {
    "keyword": "atomic_cancel",
    "usage": [
      {
        "info": "ï¼ˆå®éªŒæ€§åŠŸèƒ½ï¼‰ç”¨äºäº‹åŠ¡ï¼šå£°æ˜åŸå­å—ä¸”å¯è¢«å–æ¶ˆã€‚",
        "sdsc": [
          "atomic_cancel <i>å¤åˆè¯­å¥</i>"
        ],
        "example": "int f() {\n    static int i{0};\n    atomic_cancel {\n        ++i;\n        return i;\n    }\n}"
      }
    ]
  },
  {
    "keyword": "atomic_commit",
    "usage": [
      {
        "info": "ï¼ˆå®éªŒæ€§åŠŸèƒ½ï¼‰ç”¨äºäº‹åŠ¡ï¼šå£°æ˜åŸå­å—ä¸”æŠ›å‡ºå¼‚å¸¸ã€‚",
        "sdsc": [
          "atomic_ommit <i>å¤åˆè¯­å¥</i>"
        ],
        "example": "int f() {\n    static int i{0};\n    atomic_commit {\n        ++i;\n        return i;\n    }\n}"
      }
    ]
  },
  {
    "keyword": "atomic_noexcept",
    "usage": [
      {
        "info": "ï¼ˆå®éªŒæ€§åŠŸèƒ½ï¼‰ç”¨äºäº‹åŠ¡ï¼šå£°æ˜åŸå­å—ä¸”é‡å¼‚å¸¸æ­£å¸¸æäº¤ã€‚",
        "sdsc": [
          "atomic_noexcept <i>å¤åˆè¯­å¥</i>"
        ],
        "example": "int f() {\n    static int i{0};\n    atomic_noexcept {\n        ++i;\n        return i;\n    }\n}"
      }
    ]
  },
  {
    "keyword": "auto",
    "usage": [
      {
        "info": "1. ç”¨äºå£°æ˜ï¼šè‡ªåŠ¨æ¨å¯¼ç±»å‹å£°æ˜ç¬¦ã€‚å¯¹äºå˜é‡ï¼Œå°†é€šè¿‡åˆå§‹åŒ–å€¼æ¨å¯¼å…¶ç±»å‹ï¼›å¯¹äºå‡½æ•°ï¼Œå°†é€šè¿‡returnè¯­å¥æ¨å¯¼å…¶è¿”å›ç±»å‹ã€‚å¯¹äºæ¨¡æ¿å½¢å‚ï¼Œé€šè¿‡å®å‚æ¨å¯¼å…¶ç±»å‹ã€‚",
        "sdsc": [
          "auto <i>å£°æ˜ç¬¦</i> <i>åˆå§‹åŒ–å™¨</i>;",
          "decltype(auto) <i>å£°æ˜ç¬¦</i> <i>åˆå§‹åŒ–å™¨</i>;"
        ],
        "example": "int a = 42;\nint& ra = a;\nauto a1 = ra; // int\ndecltype(auto) a2 = ra; // int&\nauto f() {\n    return 42;\n} // int f();"
      },
      {
        "info": "2. ç”¨äºå£°æ˜ï¼šå£°æ˜ç»“æ„åŒ–ç»‘å®šã€‚",
        "sdsc": [
          "auto<opt-block><x-or>&amp;<hr>&amp;&amp;</x-or></opt-block> [<i>æ ‡è¯†ç¬¦åˆ—è¡¨</i>] <i>å…ƒç»„åˆå§‹åŒ–å™¨</i>;"
        ],
        "example": "int a[2] = {1, 2};\nauto [x, y] = a; // copy\nauto& [x, y] = a; // ref"
      }
    ]
  },
  {
    "keyword": "bitand",
    "usage": [
      {
        "info": "ç”¨äºè¿ç®—ç¬¦ï¼š<code>&amp;</code> çš„æ›¿ä»£å†™æ³•",
        "sdsc": [
          "<i>å·¦ä¾§æ“ä½œæ•°</i> bitand <i>å³ä¾§æ“ä½œæ•°</i>"
        ],
        "example": "a bitand b;"
      }
    ]
  },
  {
    "keyword": "bitor",
    "usage": [
      {
        "info": "ç”¨äºè¿ç®—ç¬¦ï¼š<code>|</code> çš„æ›¿ä»£å†™æ³•",
        "sdsc": [
          "<i>å·¦ä¾§æ“ä½œæ•°</i> bitor <i>å³ä¾§æ“ä½œæ•°</i>"
        ],
        "example": "a bitor b;"
      }
    ]
  },
  {
    "keyword": "bool",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šå¸ƒå°”ç±»å‹å˜é‡çš„ç±»å‹è¯´æ˜ç¬¦ã€‚",
        "sdsc": [
          "bool <i>å˜é‡å</i> <b>åˆå§‹åŒ–å™¨</b>;"
        ],
        "example": "bool flag{false};"
      }
    ]
  },
  {
    "keyword": "break",
    "usage": [
      {
        "info": "ç”¨äºæ§åˆ¶æˆåˆ†ï¼šbreak è¯­å¥è·³å‡ºå½“å‰ forã€whileã€do-while æˆ– switch è¯­å¥ã€‚",
        "sdsc": [
          "break;"
        ],
        "example": "for(int i{0}; i < 10; i++) {\n    if (i == 5) break;\n}"
      }
    ]
  },
  {
    "keyword": "case",
    "usage": [
      {
        "info": "ç”¨äºæ§åˆ¶æˆåˆ†ï¼šåœ¨switchè¯­å¥ä¸­ï¼Œä½œä¸ºè¯­å¥æ ‡å·ç¡®å®šå…¥å£ã€‚",
        "sdsc": [
          "case <i>å¸¸é‡</i> : <i>è¯­å¥</i>"
        ],
        "example": "switch(score) {\n    case 100: n++; break;\n}"
      }
    ]
  },
  {
    "keyword": "catch",
    "usage": [
      {
        "info": "ç”¨äºå¼‚å¸¸å¤„ç†ï¼šæ•è·å¼‚å¸¸å¹¶å¤„ç†ã€‚",
        "sdsc": [
          "try <i>å¤åˆè¯­å¥</i>\ncatch (<x-or><i>å£°æ˜åºåˆ—</i><hr>...</x-or>) <i>å¤åˆè¯­å¥</i>"
        ],
        "example": "try {\n    str.substr(10);\n} catch (std::exception e) {\n    std::cerr << e.what();\n}\ntry {\n    f();\n} catch (...) {\n    // who cares?\n}"
      }
    ]
  },
  {
    "keyword": "char",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šå­—ç¬¦ç±»å‹å˜é‡çš„ç±»å‹è¯´æ˜ç¬¦ã€‚",
        "sdsc": [
          "char <i>å˜é‡å</i> <b>åˆå§‹åŒ–å™¨</b>;"
        ],
        "example": "char result{'G'};"
      }
    ]
  },
  {
    "keyword": "char8_t",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šUTF-8 å­—ç¬¦ç±»å‹å˜é‡çš„ç±»å‹è¯´æ˜ç¬¦ã€‚",
        "sdsc": [
          "char8_t <i>å˜é‡å</i> <b>åˆå§‹åŒ–å™¨</b>;"
        ],
        "example": "char8_t ch{u8'G'}"
      }
    ]
  },
  {
    "keyword": "char16_t",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šUTF-16 å­—ç¬¦ç±»å‹å˜é‡çš„ç±»å‹è¯´æ˜ç¬¦ã€‚",
        "sdsc": [
          "char16_t <i>å˜é‡å</i> <b>åˆå§‹åŒ–å™¨</b>;"
        ],
        "example": "char16_t hanzi{u'å­—'};"
      }
    ]
  },
  {
    "keyword": "char32_t",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šUTF-32 å­—ç¬¦ç±»å‹å˜é‡çš„ç±»å‹è¯´æ˜ç¬¦ã€‚",
        "sdsc": [
          "char32_t <i>å˜é‡å</i> <b>åˆå§‹åŒ–å™¨</b>;"
        ],
        "example": "char32_t emoji{U'ğŸŒ'};"
      }
    ]
  },
  {
    "keyword": "class",
    "usage": [
      {
        "info": "1. ç”¨äºå£°æ˜ï¼šå£°æ˜é»˜è®¤ä¸ºç§æœ‰æˆå‘˜çš„ç±»ç±»å‹ã€‚",
        "sdsc": [
          "class <b>ç±»å</b> {\n    <b>æˆå‘˜åˆ—è¡¨</b>\n};"
        ],
        "example": "class Student {\npublic:\n    int no;\n    std::string name;\n    bool sex;\n};"
      },
      {
        "info": "2. ç”¨äºå£°æ˜ï¼šå£°æ˜æœ‰ä½œç”¨åŸŸæšä¸¾ç±»å‹ã€‚",
        "sdsc": [
          "enum <x-or>class<hr>struct</x-or> <i>æšä¸¾å</i> {\n    <b>æšä¸¾é¡¹åˆ—è¡¨</b>\n};"
        ],
        "example": "enum class Color {\n    Red,\n    Blue,\n    Green\n};"
      },
      {
        "info": "3. ç”¨äºæ¨¡æ¿ï¼šç”¨äºå¼•å…¥ç±»å‹æ¨¡æ¿å½¢å‚ï¼Œä¸ <code>typename</code> ç­‰ä»·ã€‚",
        "sdsc": [
          "template &lt;<x-or>class<hr>typename</x-or> <b>ç±»å‹å½¢å‚</b>&gt;\n<i>å£°æ˜</i>"
        ],
        "example": "template <class T>\nT& max(const T& a,const T& b) {\n    return a > b ? a : b;\n}"
      }
    ]
  },
  {
    "keyword": "compl",
    "usage": [
      {
        "info": "ç”¨äºè¿ç®—ç¬¦ï¼š<code>~</code>çš„æ›¿ä»£å†™æ³•ã€‚",
        "sdsc": [
          "compl <i>æ“ä½œæ•°</i>"
        ],
        "example": "compl a;"
      }
    ]
  },
  {
    "keyword": "concept",
    "usage": [
      {
        "info": "ç”¨äºçº¦æŸï¼šå®šä¹‰ä¸€ä¸ªæ¦‚å¿µï¼ˆåˆç§°çº¦æŸé›†åˆï¼‰ã€‚",
        "sdsc": [
          "template &lt;<i>æ¨¡æ¿å½¢å‚åˆ—è¡¨</i>&gt;\nconcept <i>æ¦‚å¿µå</i> = <i>çº¦æŸè¡¨è¾¾å¼</i>;"
        ],
        "example": "template <typename T, typename U>\nconcept Derived = std::is_base_of<U, T>::value;"
      }
    ]
  },
  {
    "keyword": "const",
    "usage": [
      {
        "info": "1. ç”¨äºå£°æ˜ï¼šé™å®šå˜é‡åªè¯»ã€‚",
        "sdsc": [
          "const <i>ç±»å‹è¯´æ˜ç¬¦</i> <i>å˜é‡å</i> <i>åˆå§‹åŒ–å™¨</i>;"
        ],
        "example": "const float PI{3.14f};"
      },
      {
        "info": "2. ç”¨äºå£°æ˜ï¼šé™å®šæˆå‘˜å‡½æ•°å¯¹æˆå‘˜åªè¯»ã€‚",
        "sdsc": [
          "<i>è¿”å›ç±»å‹</i> <i>å‡½æ•°å</i>(<b>å½¢å‚åˆ—è¡¨</b>) const;"
        ],
        "example": "struct Coord {\n    int x;\n    int y;\n    double mod() const {\n        return std::sqrt(x * x + y * y);\n    }\n};"
      }
    ]
  },
  {
    "keyword": "consteval",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šæŒ‡ç¤ºå‡½æ•°ä¸ºå³æ—¶å‡½æ•°ï¼ˆImmediate Functionï¼‰ï¼Œå³æ¯æ¬¡è°ƒç”¨å¿…é¡»åœ¨äº§ç”Ÿç¼–è¯‘æœŸå¸¸é‡ã€‚",
        "sdsc": [
          "consteval <i>è¿”å›ç±»å‹</i> <i>å‡½æ•°å</i>(<b>å½¢å‚åˆ—è¡¨</b>);"
        ],
        "example": "consteval int sqr(int n) {\n    return n * n;\n}"
      }
    ]
  },
  {
    "keyword": "constexpr",
    "usage": [
      {
        "info": "1. ç”¨äºå£°æ˜ï¼šæŒ‡ç¤ºå‡½æ•°æˆ–è€…å˜é‡çš„å€¼å¯ä»¥ç”¨äºå¸¸é‡è¡¨è¾¾å¼ã€‚å¯¹äºå˜é‡ï¼Œé™å®šä¸ºåªè¯»çš„ã€‚",
        "sdsc": [
          "constexpr <i>ç±»å‹è¯´æ˜ç¬¦</i> <i>å˜é‡å</i> <i>åˆå§‹åŒ–å™¨</i>;",
          "constexpr <i>è¿”å›ç±»å‹</i> <i>å‡½æ•°å</i>(<b>å½¢å‚åˆ—è¡¨</b>);"
        ],
        "example": "constexpr int fact (int n) {\n    return n <= 1 ? 1 : (n * factorial(n - 1));\n}\nconstexpr int a{fact(4)};"
      },
      {
        "info": "2. ç”¨äºæ§åˆ¶æˆåˆ†ï¼šè¡¨æ˜ if è¯­å¥å«ä¹‰ä¸ºæ¡ä»¶ç¼–è¯‘è€Œéæ¡ä»¶è¿è¡Œã€‚",
        "sdsc": [
          "if constexpr (<i>å¸¸é‡è¡¨è¾¾å¼</i>) <i>çœŸåˆ†æ”¯è¯­å¥</i>\n<opt-block>else <i>å‡åˆ†æ”¯è¯­å¥</i></opt-block>"
        ],
        "example": "void f() {\n    if constexpr (true) {\n        i++;\n    }\n}"
      }
    ]
  },
  {
    "keyword": "constinit",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šæŒ‡ç¤ºå˜é‡çš„åˆå§‹åŒ–å¿…é¡»ä¸ºé™æ€åˆå§‹åŒ–ï¼ˆé›¶åˆå§‹åŒ–æˆ–è€…å¸¸é‡åˆå§‹åŒ–ï¼‰ï¼Œä½†ä¸é™å®šä¸ºåªè¯»çš„ã€‚",
        "sdsc": [
          "constinit <i>ç±»å‹è¯´æ˜ç¬¦</i> <i>å˜é‡å</i> <i>åˆå§‹åŒ–å™¨</i>;"
        ],
        "example": "constexpr int fact (int n) {\n    return n <= 1 ? 1 : (n * factorial(n - 1));\n}\nconstinit int a{fact(4)};"
      }
    ]
  },
  {
    "keyword": "const_cast",
    "usage": [
      {
        "info": "ç”¨äºè¿ç®—ç¬¦ï¼šå¯¹äºæŒ‡é’ˆå’Œå¼•ç”¨è¿›è¡Œè½¬æ¢ï¼Œå¯ä»¥ç§»é™¤å¸¸é‡æ€§ã€‚",
        "sdsc": [
          "const_cast&lt;<i>æ–°ç±»å‹</i>&gt;(<i>æŒ‡é’ˆæˆ–å¼•ç”¨</i>)"
        ],
        "example": "const int a = 42;\nint* pa = const_cast<int*>(&a);\nint& ra = const_cast<int&>(a);"
      }
    ]
  },
  {
    "keyword": "continue",
    "usage": [
      {
        "info": "ç”¨äºæ§åˆ¶æˆåˆ†ï¼šcontinue è¯­å¥ç”¨äºè·³è¿‡ forã€while æˆ– do-while çš„å‰©ä½™éƒ¨åˆ†ã€‚",
        "sdsc": [
          "continue;"
        ],
        "example": "for (int i{0}; i < 10; i++) {\n    if(i != 5) continue;\n}"
      }
    ]
  },
  {
    "keyword": "co_await",
    "usage": [
      {
        "info": "ç”¨äºåç¨‹ï¼šæ­¤è¿ç®—ç¬¦æš‚åœå½“å‰åç¨‹ç›´è‡³ç­‰å¾…ä½“æ¢å¤ã€‚",
        "sdsc": [
          "co_await <i>ç­‰å¾…ä½“</i>"
        ],
        "example": "task<> tcp_echo_server() {\n    char data[1024];\n    for (;;) {\n        std::size_t n = co_await socket.async_read_some(buffer(data));\n        co_await async_write(socket, buffer(data, n));\n    }\n}"
      }
    ]
  },
  {
    "keyword": "co_return",
    "usage": [
      {
        "info": "ç”¨äºåç¨‹ï¼šæ­¤è¯­å¥å®Œæˆåç¨‹æ‰§è¡Œï¼Œå¹¶è¿”å›ä¸€ä¸ªå€¼ã€‚",
        "sdsc": [
          "co_return <b>è¿”å›å€¼</b>;"
        ],
        "example": "lazy<int> f() {\n    co_return 7;\n}"
      }
    ]
  },
  {
    "keyword": "co_yield",
    "usage": [
      {
        "info": "ç”¨äºåç¨‹ï¼šæ­¤è¿ç®—ç¬¦æš‚åœå½“å‰åç¨‹å¹¶è¿”å›ä¸€ä¸ªå€¼ã€‚",
        "sdsc": [
          "co_yield <i>æ“ä½œæ•°</i>"
        ],
        "example": "generator<int> iota(int n{0}) {\n    while(true)\n        co_yield n++;\n}"
      }
    ]
  },
  {
    "keyword": "decltype",
    "usage": [
      {
        "info": "1. ç”¨äºå£°æ˜ç­‰ï¼šæ£€æŸ¥å®ä½“æˆ–è¡¨è¾¾å¼çš„ç±»å‹ã€‚",
        "sdsc": [
          "decltype(<i>å®ä½“</i>)",
          "decltype(<i>è¡¨è¾¾å¼</i>)"
        ],
        "example": "int a;\ndecltype(a) x; // int\ndecltype((a)) y; // int&\ndecltype(42) z; // int"
      },
      {
        "info": "2. ç”¨äºå£°æ˜ï¼šé…åˆautoè¯´æ˜ç¬¦ï¼Œä¿ç•™å¼•ç”¨è¯­ä¹‰ã€‚",
        "sdsc": [
          "decltype(auto) <i>å˜é‡å</i> <i>åˆå§‹åŒ–å™¨</i>;"
        ],
        "example": "int a;\nint& ra{a};\ndecltype(auto) a2{ra}; // int&"
      }
    ]
  },
  {
    "keyword": "default",
    "usage": [
      {
        "info": "1. ç”¨äºæ§åˆ¶æˆåˆ†ï¼šåœ¨switchè¯­å¥ä¸­ï¼Œä½œä¸ºè¯­å¥æ ‡å·ç¡®å®šé»˜è®¤å…¥å£ã€‚",
        "sdsc": [
          "default: <i>è¯­å¥</i>"
        ],
        "example": "switch(score){\n    default: n++;\n}"
      },
      {
        "info": "2. ç”¨äºå£°æ˜ï¼šæ˜¾ç¤ºå£°æ˜éšå¼æˆå‘˜å‡½æ•°ï¼ˆé»˜è®¤æ„é€ å‡½æ•°ã€å¤åˆ¶æ„é€ å‡½æ•°ã€ç§»åŠ¨æ„é€ å‡½æ•°ã€èµ‹å€¼è¿ç®—ç¬¦ã€ææ„å‡½æ•°å’Œä¸‰è·¯æ¯”è¾ƒè¿ç®—ç¬¦ï¼‰ã€‚",
        "sdsc": [
          "<b>è¿”å›ç±»å‹</b> å‡½æ•°å(<b>å½¢å‚åˆ—è¡¨</b>) = default;"
        ],
        "example": "struct S {\n    int m;\n    S() = default;\n    auto operator<=>(const S&) const = default;\n};"
      }
    ]
  },
  {
    "keyword": "delete",
    "usage": [
      {
        "info": "1. ç”¨äºè¿ç®—ç¬¦ï¼šé‡Šæ”¾ new è¡¨è¾¾å¼åˆ†é…çš„æŒ‡é’ˆæ‰€æŒ‡å‘çš„å†…å­˜ã€‚",
        "sdsc": [
          "delete <i>æŒ‡é’ˆ</i>",
          "delete[] <i>æŒ‡é’ˆ</i>"
        ],
        "example": "int* p1 = new int(42);\nint* p2 = new int[10];\ndelete p1;\ndelete[] p2;"
      },
      {
        "info": "2. ç”¨äºå£°æ˜ï¼šå£°æ˜æˆå‘˜å‡½æ•°è¢«å¼ƒç½®",
        "sdsc": [
          "<b>è¿”å›ç±»å‹</b> å‡½æ•°å(<b>å½¢å‚åˆ—è¡¨</b>) = delete;"
        ],
        "example": "struct S {\n    S(const S&) = delete;\n};"
      }
    ]
  },
  {
    "keyword": "do",
    "usage": [
      {
        "info": "ç”¨äºæ§åˆ¶æˆåˆ†ï¼šå½¢æˆdo-whileå¾ªç¯ã€‚",
        "sdsc": [
          "do\n    <i>è¯­å¥</i>\nwhile(<i>è¡¨è¾¾å¼</i>);"
        ],
        "example": "int i{0};\ndo {\n    i++;\n} while (i < 10);"
      }
    ]
  },
  {
    "keyword": "double",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šåŒç²¾åº¦æµ®ç‚¹ç±»å‹å˜é‡çš„ç±»å‹è¯´æ˜ç¬¦ã€‚",
        "sdsc": [
          "double <i>å˜é‡å</i> <b>åˆå§‹åŒ–å™¨</b>"
        ],
        "example": "double score{60.5};"
      }
    ]
  },
  {
    "keyword": "dynamic_cast",
    "usage": [
      {
        "info": "ç”¨äºè¿ç®—ç¬¦ï¼šå°†æŒ‡å‘ç±»çš„æŒ‡é’ˆï¼ˆå¼•ç”¨ï¼‰æ²¿ç»§æ‰¿å±‚çº§å®‰å…¨åœ°è½¬æ¢åˆ°å…¶å®ƒç±»çš„æŒ‡é’ˆï¼ˆå¼•ç”¨ï¼‰ã€‚è‹¥è½¬å‹å¤±è´¥ï¼Œè¿”å›ç©ºæŒ‡é’ˆã€‚ï¼ˆè‹¥ä¸ºå¼•ç”¨ï¼ŒæŠ›å‡ºå¼‚å¸¸ã€‚ï¼‰",
        "sdsc": [
          "dynamic_cast&lt;<i>æ–°ç±»å‹</i>&gt;(<i>æŒ‡é’ˆæˆ–å¼•ç”¨</i>)"
        ],
        "example": "struct Base {\n    virtual ~Base() {}\n}\nstruct Derived : Base {}\nint main(){\n    Base* b{new Base};\n    Derived* d{dynamic_cast<Derived*>(b)};"
      }
    ]
  },
  {
    "keyword": "else",
    "usage": [
      {
        "info": "ç”¨äºæ§åˆ¶æˆåˆ†ã€‚å½¢æˆ if è¯­å¥çš„å‡åˆ†æ”¯ã€‚",
        "sdsc": [
          "if (<i>æ¡ä»¶</i>)\n    <i>çœŸåˆ†æ”¯è¯­å¥</i>\nelse\n    <i>å‡åˆ†æ”¯è¯­å¥</i>"
        ],
        "example": "if (flag) {\n    std::cout << \"Yes\";\nelse\n    std::cout << \"No\";\n\n   "
      }
    ]
  },
  {
    "keyword": "enum",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šå£°æ˜æšä¸¾ç±»å‹ã€‚",
        "sdsc": [
          "enum <opt-block><x-or>class<hr>struct</x-or></opt-block> <b>æšä¸¾å</b> <opt-block>: <i>åŸº</i></opt-block> {\n    <b>æšä¸¾é¡¹åˆ—è¡¨</b>\n};"
        ],
        "example": "enum Color { Red, Black };\nenum class Status { Free, Busy };"
      }
    ]
  },
  {
    "keyword": "explicit",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šé™åˆ¶æ„é€ å‡½æ•°ä¸ºæ˜¾å¼ï¼Œå³ä¸èƒ½ç”¨äºéšå¼è½¬æ¢å’Œå¤åˆ¶åˆå§‹åŒ–ã€‚å¯åæ¥å¸¸é‡è¡¨è¾¾å¼ï¼Œå½“å¸¸é‡è¡¨è¾¾å¼ä¸ºtrueæ—¶ä¸ºæ˜¾å¼ã€‚",
        "sdsc": [
          "explict <i>æ„é€ å‡½æ•°å</i>(<b>å½¢å‚åˆ—è¡¨</b>);",
          "explict (<i>å¸¸é‡è¡¨è¾¾å¼</i>) <i>æ„é€ å‡½æ•°å</i>(<b>å½¢å‚åˆ—è¡¨</b>);"
        ],
        "example": "struct A {\n    explicit A(int) { }\n};\nstruct B {\n    explicit (true) B(int) { }\n};\nint main() {\n    A a(42); // not A a = 42;\n}"
      }
    ]
  },
  {
    "keyword": "export",
    "usage": [
      {
        "info": "ç”¨äºæ¨¡å—ï¼šæ ‡è®°ä¸€ä¸ªå£°æ˜æˆ–ä¸€ä¸ªæ¨¡å—è¢«å½“å‰æ¨¡å—å¯¼å‡ºã€‚",
        "sdsc": [
          "export module <i>æ¨¡å—å</i>;",
          "export <i>å£°æ˜</i>;"
        ],
        "example": "// hello.cpp\nexport module my.app.hello;\nexport auto sayHello() {\n    return \"Hello!\";\n}\n// main.cpp\nimport my.app.hello;\nimport <iostream>\nint main() {\n    std::cout << sayHello();\n}"
      }
    ]
  },
  {
    "keyword": "extern",
    "usage": [
      {
        "info": "1. ç”¨äºå£°æ˜ï¼šå£°æ˜å¯¹è±¡å…·æœ‰é™æ€å­˜å‚¨æœŸå’Œå¤–éƒ¨è¿æ¥ï¼›å³åœ¨å…¶å®ƒæ–‡ä»¶ä¸­å¯»æ‰¾å¯¹è±¡çš„å®šä¹‰ã€‚",
        "sdsc": [
          "extern <i>ç±»å‹è¯´æ˜ç¬¦</i> <i>å˜é‡å</i>;"
        ],
        "example": "// score.cpp\nint score{60};\n// main.cpp\n#include <iostream>\nextern int score;\nint main() {\n    std::cout << score;\n} // 60"
      },
      {
        "info": "2. å…¶å®ƒï¼šç”¨äºè¿æ¥å…¶å®ƒè¯­è¨€ç¼–å†™çš„ä»£ç ã€‚ä¸€èˆ¬åªæ”¯æŒCè¯­è¨€ã€‚",
        "sdsc": [
          "extern <i>å­—ç¬¦ä¸²å­—é¢é‡</i> <x-or>{ <i>å£°æ˜åºåˆ—</i> }<hr><i>å£°æ˜</i></x-or>"
        ],
        "example": "extern \"C\" {\n    static void f();\n}\nextern \"C\" void g() {\n     printf(\"Hello\");\n}"
      },
      {
        "info": "3. ç”¨äºæ¨¡æ¿ï¼šæ˜¾å¼å®ä¾‹åŒ–å£°æ˜ç±»æ¨¡æ¿ï¼Œä½†è·³è¿‡éšå¼å®ä¾‹åŒ–æ­¥éª¤ï¼›å³åœ¨å…¶å®ƒæ–‡ä»¶ä¸­å¯»æ‰¾å®ä¾‹åŒ–å®šä¹‰ã€‚",
        "sdsc": [
          "extern template <x-or>class<hr>struct</x-or> <i>æ¨¡æ¿å</i>&lt;<b>æ¨¡æ¿å®å‚åˆ—è¡¨</b>&gt;;"
        ],
        "example": "template<typename T> struct Z { };\n// find instantiation in other place\nextern template struct Z<double>;"
      }
    ]
  },
  {
    "keyword": "false",
    "usage": [
      {
        "info": "ç”¨äºæ•°æ®æˆåˆ†ï¼šè¡¨ç¤ºå‡çš„å¸ƒå°”ç±»å‹å­—é¢å€¼ã€‚",
        "sdsc": [
          "false"
        ],
        "example": "bool flag{false};"
      }
    ]
  },
  {
    "keyword": "float",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šå•ç²¾åº¦æµ®ç‚¹ç±»å‹å˜é‡çš„ç±»å‹è¯´æ˜ç¬¦ã€‚",
        "sdsc": [
          "float <i>å˜é‡å</i> <b>åˆå§‹åŒ–å™¨</b>"
        ],
        "example": "float score{60.5f};"
      }
    ]
  },
  {
    "keyword": "for",
    "usage": [
      {
        "info": "1. ç”¨äºæ§åˆ¶æˆåˆ†ï¼šå½¢æˆforå¾ªç¯è¯­å¥ã€‚",
        "sdsc": [
          "for ( <i>åˆå§‹è¯­å¥</i> <i>æ¡ä»¶è¡¨è¾¾å¼</i>; <i>è¿­ä»£è¡¨è¾¾å¼</i>)\n    <i>è¯­å¥</i>"
        ],
        "example": "for (int i{0}; i < 10; i++){\n    std::cout << i;\n}"
      },
      {
        "info": "2. ç”¨äºæ§åˆ¶æˆåˆ†ï¼šå½¢æˆåŸºäºèŒƒå›´çš„forå¾ªç¯è¯­å¥ã€‚èŒƒå›´å¯ä»¥æ˜¯æ•°ç»„æˆ–å®¹å™¨ç­‰ã€‚",
        "sdsc": [
          "for ( <i>èŒƒå›´å£°æ˜</i> : <i>èŒƒå›´è¡¨è¾¾å¼</i>)\n    <i>è¯­å¥</i>"
        ],
        "example": "int a[10]{};\nfor (auto i : a) {\n    i++;\n}"
      }
    ]
  },
  {
    "keyword": "friend",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šå£°æ˜å‡½æ•°æˆ–ç±»ä¸ºå‹å…ƒå‡½æ•°æˆ–å‹å…ƒç±»ã€‚å‹å…ƒå‡½æ•°å’Œå‹å…ƒç±»å¯ä»¥è®¿é—®å…¶å®ƒç±»ä¸­çš„ç§æœ‰æˆå‘˜ã€‚",
        "sdsc": [
          "friend <i>å‡½æ•°å£°æ˜</i>",
          "friend <i>ç±»å</i>;"
        ],
        "example": "struct Y;\nclass X {\n    friend Y;\n    friend void g();\n    int a = 0;  // private\n};\nX x;\nstruct Y {\n    int b = x.a;\n};\nvoid g() {\n    x.a;\n}"
      }
    ]
  },
  {
    "keyword": "goto",
    "usage": [
      {
        "info": "ç”¨äºæ§åˆ¶æˆåˆ†ï¼šgotoè¯­å¥å¯æ— æ¡ä»¶è·³è½¬åˆ°å¯¹åº”æ ‡å·çš„è¯­å¥ã€‚",
        "sdsc": [
          "goto <i>è¯­å¥æ ‡å·</i>;"
        ],
        "example": "loop: x++;\nif (x < 10) goto loop;"
      }
    ]
  },
  {
    "keyword": "if",
    "usage": [
      {
        "info": "ç”¨äºæ§åˆ¶æˆåˆ†ï¼šifè¯­å¥å½¢æˆç®€å•çš„åˆ†æ”¯æµç¨‹ã€‚",
        "sdsc": [
          "if <opt-block>constexpr</opt-block> ( <b>åˆå§‹åŒ–è¯­å¥</b> <i>æ¡ä»¶è¡¨è¾¾å¼</i> )\n    <i>çœŸåˆ†æ”¯è¯­å¥</i>\n<opt-block>else\n    <i>å‡åˆ†æ”¯è¯­å¥</i></opt-block>"
        ],
        "example": "if (flag) {\n    std::cout << \"Yes\";\n}\nif (int x = getRes(); flag)\n    std::cout << x;\nelse std::cout << -x;"
      }
    ]
  },
  {
    "keyword": "inline",
    "usage": [
      {
        "info": "1. ç”¨äºå£°æ˜ï¼šå£°æ˜å‡½æ•°æˆ–å˜é‡ä¸ºå†…è”çš„ã€‚å†…è”çš„å£°æ˜å¯ä»¥å®¹è®¸å¤šæ¬¡ç­‰åŒçš„å®šä¹‰ï¼›å¯¹äºå†…è”å‡½æ•°å¯èƒ½ä¼šä¼˜å…ˆå†…è”è€Œä¸è·³è½¬ï¼ˆè¿™æ˜¯å·²ç»è¢«æ ‡å‡†æŠ›å¼ƒçš„è¯´æ³•ï¼Œä½†ä»ç„¶é€‚ç”¨ï¼‰ã€‚",
        "sdsc": [
          "inline <i>å‡½æ•°æˆ–å¯¹è±¡å£°æ˜</i>"
        ],
        "example": "inline max(const int& a, const int& b) {\n    return a > b ? a : b;\n}"
      },
      {
        "info": "2. ç”¨äºå‘½åç©ºé—´ï¼šå£°æ˜å‘½åç©ºé—´ä¸ºå†…è”çš„ï¼Œå³è¯¥å‘½åç©ºé—´çš„æˆå‘˜å¦‚åŒè§†ä¸ºå¤–å±‚å‘½åç©ºé—´çš„æˆå‘˜ã€‚",
        "sdsc": [
          "inline namespace <i>å‘½åç©ºé—´å</i> { <i>å£°æ˜åºåˆ—</i> }"
        ],
        "example": "namespace literals {\n    inline namespace string_literals {//[...]\n    }\n}"
      }
    ]
  },
  {
    "keyword": "int",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šåŸºç¡€æœ‰ç¬¦å·æ•´æ•°ç±»å‹å˜é‡çš„ç±»å‹è¯´æ˜ç¬¦ï¼Œæˆ–è€…ä½œä¸ºå…¶å®ƒæ•´å‹å˜é‡çš„ç±»å‹è¯´æ˜ç¬¦çš„éƒ¨åˆ†ã€‚",
        "sdsc": [
          "int <i>å˜é‡å</i> <b>åˆå§‹åŒ–å™¨</b>;"
        ],
        "example": "int number{42};"
      }
    ]
  },
  {
    "keyword": "long",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šæœ‰ç¬¦å·é•¿æ•´å‹å˜é‡çš„ç±»å‹è¯´æ˜ç¬¦ï¼Œæˆ–è€…ä½œä¸ºå…¶å®ƒæ•´å‹å˜é‡çš„ç±»å‹è¯´æ˜ç¬¦çš„éƒ¨åˆ†ã€‚ ",
        "sdsc": [
          "long <i>å˜é‡å</i> <b>åˆå§‹åŒ–å™¨</b>;"
        ],
        "example": "long number{42L};"
      }
    ]
  },
  {
    "keyword": "mutable",
    "usage": [
      {
        "info": "1. ç”¨äºå£°æ˜ï¼šå®¹è®¸åŒ…å«è¯¥å¯¹è±¡çš„å¯¹è±¡è¢«å£°æ˜ä¸ºåªè¯»æ—¶ä»å¯ä¿®æ”¹ã€‚",
        "sdsc": [
          "mutable <i>ç±»å‹è¯´æ˜ç¬¦</i> <i>å˜é‡å</i>;"
        ],
        "example": "class X {\n    mutable int m;\n    void f() const {m++;\n    }\n};"
      },
      {
        "info": "2. ç”¨äº Lambda è¡¨è¾¾å¼ï¼šå…è®¸ Lambda è¡¨è¾¾å¼å‡½æ•°ä½“ä¿®æ”¹å¤åˆ¶æ•è·çš„å®å‚ã€‚",
        "sdsc": [
          "[<b>æ•è·</b>](<b>å‚æ•°åˆ—è¡¨</b>) mutable <opt-block>-&gt; è¿”å›ç±»å‹</opt-block> <i>å‡½æ•°ä½“</i>"
        ],
        "example": "int a = 3;\nauto add = [a]() mutable -> void { a++; };"
      }
    ]
  },
  {
    "keyword": "namespace",
    "usage": [
      {
        "info": "1. ç”¨äºå‘½åç©ºé—´ï¼šå»ºç«‹å‘½åç©ºé—´æˆ–å¼•å…¥å‘½åç©ºé—´ï¼Œä»è€Œé¿å…å‘½åå†²çªã€‚",
        "sdsc": [
          "<opt-block>inline</opt-block> namespace <b>å‘½åç©ºé—´å</b> { <b>å£°æ˜åºåˆ—</b> }",
          "using namespace <i>å‘½åç©ºé—´å</i>;"
        ],
        "example": "using namespace std;\nnamespace MyApp {\n    int x;\n}\nint main() {\n    MyApp::x;\n}"
      },
      {
        "info": "2. ç”¨äºå‘½åç©ºé—´ï¼šåˆ›ç«‹å‘½åç©ºé—´åˆ«åã€‚",
        "sdsc": [
          "namespace <i>åˆ«å</i> = <i>å‘½åç©ºé—´å</i>;"
        ],
        "example": "namespace foo {\n    namespace bar {int m;\n    }\n}\nnamespace fb = foo::bar;\nint main() {\n    fb::m;\n}"
      }
    ]
  },
  {
    "keyword": "new",
    "usage": [
      {
        "info": "ç”¨äºè¿ç®—ç¬¦ï¼šåˆ›å»ºå¹¶åˆå§‹åŒ–å…·æœ‰åŠ¨æ€å­˜å‚¨æœŸçš„å¯¹è±¡ï¼Œè¿”å›æŒ‡å‘è¯¥å¯¹è±¡çš„æŒ‡é’ˆæˆ–è€…æŒ‡å‘æ•°ç»„é¦–å…ƒç´ çš„æŒ‡é’ˆã€‚",
        "sdsc": [
          "new <i>ç±»å‹</i>;",
          "new <i>ç±»å‹</i>[<i>é•¿åº¦</i>];"
        ],
        "example": "int* p1 = new int(42);\nint* p2 = new int[10];\ndelete p1;\ndelete[] p2;"
      }
    ]
  },
  {
    "keyword": "noexcept",
    "usage": [
      {
        "info": "1. ç”¨äºå£°æ˜ï¼šæŒ‡ç¤ºè¯¥å‡½æ•°ä¸ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œä»è€Œç¼–è¯‘æ—¶ä¼˜åŒ–ã€‚å¯åéšå¸¸é‡è¡¨è¾¾å¼ï¼Œå½“è¡¨è¾¾å¼ä¸º true æ—¶ä¸ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚",
        "sdsc": [
          "<b>è¿”å›ç±»å‹</b> <i>å‡½æ•°å</i>(<b>å½¢å‚åˆ—è¡¨</b>) noexcept;",
          "<b>è¿”å›ç±»å‹</b> <i>å‡½æ•°å</i>(<b>å½¢å‚åˆ—è¡¨</b>) noexcept(<i>å¸¸é‡è¡¨è¾¾å¼</i>)"
        ],
        "example": "void f() noexcept {}\nvoid g() noexcept(false) {} // g may throw exception\nvoid h() noexcept(true) {}"
      },
      {
        "info": "2.\n            ç”¨äºè¿ç®—ç¬¦ï¼šæ£€æŸ¥è¡¨è¾¾å¼æ˜¯å¦å¯èƒ½æŠ›å‡ºå¼‚å¸¸ã€‚è‹¥ä¸å¯èƒ½ï¼Œè¿”å› true ï¼›å¦åˆ™è¿”å› falseã€‚è¯¥è¿ç®—ç¬¦ä¸å¯¹è¡¨è¾¾å¼æ±‚å€¼ã€‚",
        "sdsc": [
          "noexcept(<i>è¡¨è¾¾å¼</i>)"
        ],
        "example": "void f() noexcept {}\nvoid g() {}\nint main() {\n    noexcept(f()); // true\n    noexcept(g()); // false\n}"
      }
    ]
  },
  {
    "keyword": "not",
    "usage": [
      {
        "info": "ç”¨äºè¿ç®—ç¬¦ï¼š<code>!</code>çš„æ›¿ä»£å†™æ³•ã€‚",
        "sdsc": [
          "not <i>æ“ä½œæ•°</i>"
        ],
        "example": "not isOK;"
      }
    ]
  },
  {
    "keyword": "not_eq",
    "usage": [
      {
        "info": "ç”¨äºè¿ç®—ç¬¦ï¼š<code>!=</code>çš„æ›¿ä»£å†™æ³•ã€‚",
        "sdsc": [
          "<i>å·¦ä¾§æ“ä½œæ•°</i> not_eq <i>å³ä¾§æ“ä½œæ•°</i>"
        ],
        "example": "a not_eq b;"
      }
    ]
  },
  {
    "keyword": "nullptr",
    "usage": [
      {
        "info": "ç”¨äºæ•°æ®æˆåˆ†ï¼šç©ºæŒ‡é’ˆå­—é¢é‡ï¼Œå¯ä¸å…¶ä½™ç±»å‹æŒ‡é’ˆéšå¼æˆ–æ˜¾å¼è½¬æ¢ã€‚",
        "sdsc": [
          "nullptr"
        ],
        "example": "int* pointer = nullptr;"
      }
    ]
  },
  {
    "keyword": "operator",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šå£°æ˜é‡è½½è¿ç®—ç¬¦ã€‚",
        "sdsc": [
          "<b>è¿”å›ç±»å‹</b> operator<i>è¿ç®—ç¬¦</i> (<b>å½¢å‚åˆ—è¡¨</b>);"
        ],
        "example": "struct A {\n    int m;\n    bool operator<(const A& b) const {return m < b.m;\n    }\n};"
      }
    ]
  },
  {
    "keyword": "or",
    "usage": [
      {
        "info": "ç”¨äºè¿ç®—ç¬¦ï¼š<code>||</code>çš„æ›¿ä»£å†™æ³•ã€‚",
        "sdsc": [
          "<i>å·¦ä¾§æ“ä½œæ•°</i> or <i>å³ä¾§æ“ä½œæ•°</i>"
        ],
        "example": "a or b;"
      }
    ]
  },
  {
    "keyword": "or_eq",
    "usage": [
      {
        "info": "ç”¨äºè¿ç®—ç¬¦ï¼š<code>|=</code>çš„æ›¿ä»£å†™æ³•ã€‚",
        "sdsc": [
          "<i>å·¦ä¾§æ“ä½œæ•°</i> or_eq <i>å³ä¾§æ“ä½œæ•°</i>"
        ],
        "example": "a or_eq b;"
      }
    ]
  },
  {
    "keyword": "private",
    "usage": [
      {
        "info": "ç”¨äºé¢å‘å¯¹è±¡ï¼šæŒ‡æ˜å…¶åçš„æˆå‘˜ä¸ºç§æœ‰æˆå‘˜ï¼Œæˆ–è€…æŒ‡æ˜è¯¥ç±»ä¸ºç§æœ‰ç»§æ‰¿ã€‚",
        "sdsc": [
          "private: ",
          "<x-or>class<hr>struct</x-or> <b>ç±»å</b> : private <i>çˆ¶ç±»å</i> {\n    <b>æˆå‘˜åˆ—è¡¨</b>\n};"
        ],
        "example": "struct A {\nprivate:\n    int m;\n};\nstruct B : private A {};"
      }
    ]
  },
  {
    "keyword": "protected",
    "usage": [
      {
        "info": "ç”¨äºé¢å‘å¯¹è±¡ï¼šæŒ‡æ˜å…¶åçš„æˆå‘˜ä¸ºå—ä¿æŠ¤æˆå‘˜ï¼Œæˆ–è€…æŒ‡æ˜è¯¥ç±»ä¸ºå—ä¿æŠ¤ç»§æ‰¿ã€‚",
        "sdsc": [
          "protected: ",
          "<x-or>class<hr>struct</x-or> <b>ç±»å</b> : protected <i>çˆ¶ç±»å</i> {\n    <b>æˆå‘˜åˆ—è¡¨</b> \n};"
        ],
        "example": "struct A {\nprotected:\n    int m;\n};\nstruct B : protected A {};"
      }
    ]
  },
  {
    "keyword": "public",
    "usage": [
      {
        "info": "ç”¨äºé¢å‘å¯¹è±¡ï¼šæŒ‡æ˜å…¶åçš„æˆå‘˜ä¸ºå…¬æœ‰æˆå‘˜ï¼Œæˆ–è€…æŒ‡æ˜è¯¥ç±»ä¸ºå—å…¬å¼€ç»§æ‰¿ã€‚",
        "sdsc": [
          "public: ",
          "<x-or>class<hr>struct</x-or> <b>ç±»å</b> : public <i>çˆ¶ç±»å</i> {\n    <b>æˆå‘˜åˆ—è¡¨</b> \n};"
        ],
        "example": "class A {\npublic:\n    int m;\n};\nclass B : public A {};"
      }
    ]
  },
  {
    "keyword": "reflexpr",
    "usage": [
      {
        "info": "ï¼ˆå®éªŒæ€§åŠŸèƒ½ï¼‰ç”¨äºåå°„ã€‚è·å–æŸä¸ªç±»å‹çš„åå°„å…ƒç±»å‹ã€‚ï¼ˆå…ƒç±»å‹æ˜¯æŒ‡åŒ…å«è¿™ä¸ªç±»çš„å…ƒæ•°æ®çš„ç±»å‹ï¼Œå¦‚ç±»å‹åã€æˆå‘˜åˆ—è¡¨å…ƒç»„ç­‰ã€‚ï¼‰",
        "sdsc": [
          "reflexpr(<i>reflexpræ“ä½œæ•°</i>)"
        ],
        "example": "struct S { /* ... */ };\nusing meta_S = reflexpr(S);"
      }
    ]
  },
  {
    "keyword": "register",
    "usage": [
      {
        "info": "ï¼ˆæ­¤å…³é”®å­—è¢«ä¿ç•™ï¼Œæš‚æ—¶ä¸ä½¿ç”¨ã€‚ï¼‰",
        "sdsc": [],
        "example": "   "
      }
    ]
  },
  {
    "keyword": "reinterpret_cast",
    "usage": [
      {
        "info": "ç”¨äºè¿ç®—ç¬¦ï¼šå°†æŒ‡é’ˆçš„åŸºç±»å‹é‡è§£é‡Šä¸ºæ–°çš„åŸºç±»å‹ã€‚",
        "sdsc": [
          "reinterpret_cast&lt;<i>æ–°ç±»å‹</i>&gt;(<i>æŒ‡é’ˆ</i>)"
        ],
        "example": "int a = 42;\nint* pa = &a;\nlong* pb = reinterpret_cast<long*>(pa);"
      }
    ]
  },
  {
    "keyword": "requires",
    "usage": [
      {
        "info": "1. ç”¨äºæ¦‚å¿µï¼šrequires å­å¥å¯¹æ¨¡æ¿å®å‚æˆ–å‡½æ•°å£°æ˜æŒ‡å®šä¸€ä¸ªçº¦æŸï¼Œè¿™ä¸ªçº¦æŸå¯ä»¥æ˜¯æ¦‚å¿µï¼ˆçº¦æŸé›†åˆï¼‰æˆ–è€…å®ƒä»¬çš„åˆå–ã€æå–æˆ–åŸå­çº¦æŸï¼Œæˆ–è€…ä¸€ä¸ª requires è¡¨è¾¾å¼ã€‚",
        "sdsc": [
          "template&lt;<i>æ¨¡æ¿å½¢å‚åˆ—è¡¨</i>&gt; requires <i>requires å­å¥</i>\n<i>å£°æ˜</i>",
          "template&lt;<i>æ¨¡æ¿å½¢å‚åˆ—è¡¨</i>&gt;\n<i>å‡½æ•°å£°æ˜</i> requires <i>requires å­å¥</i>"
        ],
        "example": "template<typename T> requires Addable<T>\nT f(T a, T b) {\n    return a + b;\n}\ntemplate<typename T>\nT g(T a, T b) requires Addable<T> {\n    return a + b;\n}"
      },
      {
        "info": "2. ç”¨äºæ¦‚å¿µï¼šrequiresè¡¨è¾¾å¼æ„é€ ä¸€ä¸ªçº¦æŸã€‚",
        "sdsc": [
          "requires <opt-block>(<i>å½¢å‚åˆ—è¡¨</i>)</opt-block> {\n    <i>è¦æ±‚åºåˆ—</i> \n}"
        ],
        "example": "template<typename T>\nconcept Addable = requires (T x) { x + x; }"
      }
    ]
  },
  {
    "keyword": "return",
    "usage": [
      {
        "info": "ç”¨äºå‡½æ•°ï¼šç»ˆæ­¢å½“å‰å‡½æ•°ã€‚è‹¥å¯èƒ½ï¼Œåˆ™è¿”å›å€¼ç»™ä¸Šçº§å‡½æ•°ã€‚",
        "sdsc": [
          "return;",
          "return <i>è¡¨è¾¾å¼</i>;"
        ],
        "example": "void f(int i) {\n    if (i == 2) return;\n    std::cout << i;\n}\nint square(int x) {\n    return x * x;\n}"
      }
    ]
  },
  {
    "keyword": "short",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šæœ‰ç¬¦å·çŸ­æ•´å‹å˜é‡çš„ç±»å‹è¯´æ˜ç¬¦ï¼Œæˆ–è€…ä½œä¸ºå…¶å®ƒæ•´å‹å˜é‡çš„ç±»å‹è¯´æ˜ç¬¦çš„éƒ¨åˆ†ã€‚",
        "sdsc": [
          "short <i>å˜é‡å</i> <b>åˆå§‹åŒ–å™¨</b>;"
        ],
        "example": "short i;"
      }
    ]
  },
  {
    "keyword": "signed",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šåŸºç¡€æœ‰ç¬¦å·æ•´æ•°ç±»å‹çš„ç±»å‹è¯´æ˜ç¬¦ï¼Œæˆ–è€…ä½œä¸ºå…¶ä»–æœ‰ç¬¦å·æ•´å‹å˜é‡çš„ç±»å‹è¯´æ˜ç¬¦çš„éƒ¨åˆ†ã€‚",
        "sdsc": [
          "signed <i>å˜é‡å</i> <b>åˆå§‹åŒ–å™¨</b>;"
        ],
        "example": "signed score{60}; // same as int"
      }
    ]
  },
  {
    "keyword": "sizeof",
    "usage": [
      {
        "info": "1. ç”¨äºè¿ç®—ç¬¦ï¼šsizeof è¿ç®—ç¬¦æŸ¥è¯¢æ“ä½œæ•°æˆ–ç±»å‹çš„å¤§å°ã€‚å®ƒæ˜¯ä¸æ±‚å€¼è¿ç®—ç¬¦ã€‚",
        "sdsc": [
          "sizeof(<i>ç±»å‹</i>)",
          "sizeof <i>æ“ä½œæ•°</i>"
        ],
        "example": "sizeof(int);\nsizeof 42;"
      },
      {
        "info": "2. ç”¨äºè¿ç®—ç¬¦ï¼šsizeof... è¿ç®—ç¬¦æŸ¥è¯¢å½¢å‚åŒ…æ‰€å«çš„å…ƒç´ æ•°é‡ã€‚",
        "sdsc": [
          "sizeof...(<i>å½¢å‚åŒ…</i>)"
        ],
        "example": "template <typename... Args>\nstd::size_t f() {\n    return sizeof...(Args);\n}"
      }
    ]
  },
  {
    "keyword": "static",
    "usage": [
      {
        "info": "1. ç”¨äºå£°æ˜ï¼šå£°æ˜å…¨å±€å˜é‡å…·æœ‰é™æ€å­˜å‚¨æœŸå’Œå†…éƒ¨è¿æ¥ï¼Œå³ä»…èƒ½åœ¨æœ¬æ–‡ä»¶ä¸­ä½¿ç”¨ã€‚ ",
        "sdsc": [
          "static <i>ç±»å‹è¯´æ˜ç¬¦</i> <i>å˜é‡å</i> <b>åˆå§‹åŒ–å™¨</b>;"
        ],
        "example": "static int num{42};"
      },
      {
        "info": "2. ç”¨äºå£°æ˜ï¼šå£°æ˜å±€éƒ¨å˜é‡å…·æœ‰é™æ€å­˜å‚¨æœŸï¼Œå³å†…å­˜åˆ†é…æ—¶æ®µä¸ç¨‹åºæœ¬èº«ç›¸åŒï¼Œä»…åˆå§‹åŒ–ä¸€æ¬¡ã€‚",
        "sdsc": [
          "static <i>ç±»å‹è¯´æ˜ç¬¦</i> <i>å˜é‡å</i> <b>åˆå§‹åŒ–å™¨</b>;"
        ],
        "example": "void f() {\n    static int v{42};\n    v++;\n    std::cout << v;\n}\nint main() {\n    f(); // 43\n    f(); // 44\n}"
      },
      {
        "info": "3. ç”¨äºå£°æ˜ï¼šå£°æ˜é™æ€æˆå‘˜ï¼Œå³è¯¥æˆå‘˜ä¸ç»‘å®šåˆ°ç±»çš„å®ä¾‹ï¼Œä¸ºæ‰€æœ‰è¯¥ç±»å¯¹è±¡å…±æœ‰ã€‚",
        "sdsc": [
          "static <i>æˆå‘˜æˆ–å‡½æ•°å£°æ˜</i>"
        ],
        "example": "class X {\n    static int n{42};\n}\nint main() {\n    X::n;\n}"
      }
    ]
  },
  {
    "keyword": "static_assert",
    "usage": [
      {
        "info": "å…¶å®ƒï¼šè¿›è¡Œç¼–è¯‘æœŸæ–­è¨€æ£€æŸ¥ã€‚è‹¥å¸¸é‡è¡¨è¾¾å¼ä¸ºçœŸåˆ™ä¸æ‰§è¡Œæ“ä½œï¼Œå¦åˆ™ç¼–è¯‘é”™è¯¯å¹¶æç¤ºå­—ç¬¦ä¸²å­—é¢é‡çš„å†…å®¹ï¼ˆè‹¥æœ‰ï¼‰ã€‚",
        "sdsc": [
          "static_assert(<i>å¸¸é‡è¡¨è¾¾å¼</i><opt-block>, <i>å­—ç¬¦ä¸²å­—é¢é‡</i></opt-block>);"
        ],
        "example": "static_assert(false, \"Message\");\n// Compilation Error: Message"
      }
    ]
  },
  {
    "keyword": "static_cast",
    "usage": [
      {
        "info": "ç”¨äºè¿ç®—ç¬¦ï¼šè¿›è¡Œæ˜¾å¼ç±»å‹è½¬æ¢ï¼Œä½†ä¸èƒ½ç§»é™¤æŒ‡é’ˆæˆ–å¼•ç”¨çš„ const æˆ– volatile é™å®šã€‚ä»»æ„éšå¼è½¬æ¢å‡å¯ç”¨è¯è¿ç®—ç¬¦æ˜¾å¼è½¬æ¢ã€‚äº¦å­˜åœ¨åˆ° void æˆ– void çš„æŒ‡é’ˆçš„è½¬æ¢ã€æ•´æ•°ç±»å‹å’Œæšä¸¾ç±»å‹çš„è½¬æ¢ã€‚",
        "sdsc": [
          "static_cast&lt;<i>ç±»å‹</i>&gt;(<i>æ“ä½œæ•°</i>)"
        ],
        "example": "int n = static_cast<int>(3.14);"
      }
    ]
  },
  {
    "keyword": "struct",
    "usage": [
      {
        "info": "1. ç”¨äºå£°æ˜ï¼šå£°æ˜é»˜è®¤ä¸ºå…¬æœ‰æˆå‘˜çš„ç±»ç±»å‹ï¼Œå³ç»“æ„ä½“ç±»å‹ã€‚",
        "sdsc": [
          "struct <b>ç±»å</b> {\n    <b>æˆå‘˜åˆ—è¡¨</b>\n};"
        ],
        "example": "struct Student {\n    int no;\n    std::string name;\n    bool sex;\n};"
      },
      {
        "info": "2. ç”¨äºå£°æ˜ï¼šå£°æ˜æœ‰ä½œç”¨åŸŸæšä¸¾ç±»å‹ã€‚",
        "sdsc": [
          "enum <x-or>class<hr>struct</x-or> <i>æšä¸¾å</i> {\n    <b>æšä¸¾é¡¹åˆ—è¡¨</b>\n};"
        ],
        "example": "enum struct Color {\n    Red,\n    Blue,\n    Green\n};"
      }
    ]
  },
  {
    "keyword": "switch",
    "usage": [
      {
        "info": "ç”¨äºæ§åˆ¶æˆåˆ†ï¼šswitchè¯­å¥å½¢æˆå¤šåˆ†æ”¯ç»“æ„ã€‚",
        "sdsc": [
          "switch(<b>åˆå§‹è¯­å¥</b> <i>è¡¨è¾¾å¼</i>) {\n    <i>å¸¦ case æˆ– default æ ‡å·çš„è¯­å¥</i>\n}"
        ],
        "example": "switch(score) {\n    case 0: a++; break;\n    case 1: b++; break;\n    default: c++;\n}"
      }
    ]
  },
  {
    "keyword": "synchronized",
    "usage": [
      {
        "info": "ï¼ˆå®éªŒæ€§åŠŸèƒ½ï¼‰ç”¨äºäº‹åŠ¡ï¼šæŒ‡æ˜å¤åˆè¯­å¥ä¸ºåŒæ­¥å—ï¼Œå³å¦‚åŒåœ¨å…¨å±€é”ä¸‹æ‰§è¡Œã€‚",
        "sdsc": [
          "synchronized <i>å¤åˆè¯­å¥</i>"
        ],
        "example": "int f() {\n    static int i = 0;\n    sychronized {++i;return i;\n    }\n}"
      }
    ]
  },
  {
    "keyword": "template",
    "usage": [
      {
        "info": "ç”¨äºæ¨¡æ¿ï¼šå£°æ˜æ¨¡æ¿ã€‚å¯ä»¥æ˜¯ç±»æ¨¡æ¿ã€å‡½æ•°æ¨¡æ¿ã€åˆ«åæ¨¡æ¿ã€å˜é‡æ¨¡æ¿æˆ–è€…æ¦‚å¿µã€‚",
        "sdsc": [
          "template&lt;<b>å½¢å‚åˆ—è¡¨</b>&gt; <b>requires å­å¥</b>\n    <i>ç±»ã€å˜é‡æˆ–å‡½æ•°å£°æ˜</i>",
          "template&lt;<i>å½¢å‚åˆ—è¡¨</i>&gt;\nusing <i>åˆ«å</i> = <i>ç±»å‹æ ‡è¯†</i>;",
          "template&lt;<i>å½¢å‚åˆ—è¡¨</i>&gt;\nconcept <i>æ¦‚å¿µå</i> = <i>çº¦æŸè¡¨è¾¾å¼</i>;"
        ],
        "example": "template<typename T>\nT& max(const T& a, const T& b) {\n    return a > b ? a : b;\n}\ntemplate<typename T>\nusing Ptr = T*;\ntemplate<typename T>\nconcept Derived = std::is_base_of<U, T>::value;"
      }
    ]
  },
  {
    "keyword": "this",
    "usage": [
      {
        "info": "ç”¨äºé¢å‘å¯¹è±¡ï¼šä¸€ä¸ªå³å€¼æŒ‡é’ˆï¼ŒæŒ‡å‘å½“å‰æ­£åœ¨è°ƒç”¨æˆå‘˜å‡½æ•°çš„å¯¹è±¡çš„åœ°å€ã€‚å¯¹äºå…è®¸ <code>this</code> å…³é”®å­—çš„ç¯å¢ƒï¼Œè°ƒç”¨éé™æ€æˆå‘˜æ—¶ä¼šè‡ªåŠ¨æ·»åŠ éšå«çš„ <code>this-&gt;</code>ã€‚",
        "sdsc": [
          "this"
        ],
        "example": "struct S {\n    int x;\n    void add() {this->x += 1;\n    }\n};"
      }
    ]
  },
  {
    "keyword": "thread_local",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šå£°æ˜å¯¹è±¡å…·æœ‰çº¿ç¨‹å­˜å‚¨æœŸã€‚å¯¹è±¡çš„å­˜å‚¨åœ¨çº¿ç¨‹å¼€å§‹æ—¶åˆ†é…ï¼Œè€Œåœ¨çº¿ç¨‹ç»“æŸæ—¶è§£åˆ†é…ã€‚",
        "sdsc": [
          "thread_local <i>ç±»å‹è¯´æ˜ç¬¦</i> <i>å˜é‡å</i> <b>åˆå§‹åŒ–å™¨</b>;"
        ],
        "example": "thread_local unsigned int rage{1};"
      }
    ]
  },
  {
    "keyword": "throw",
    "usage": [
      {
        "info": "ç”¨äºè¿ç®—ç¬¦ï¼šå°†è¡¨è¾¾å¼å¤åˆ¶å¹¶ä½œä¸ºå¼‚å¸¸æŠ›å‡ºï¼Œæˆ–è€…é‡æ–°æŠ›å‡ºå½“å‰æ­£åœ¨å¤„ç†çš„å¼‚å¸¸ã€‚",
        "sdsc": [
          "throw <i>è¡¨è¾¾å¼</i>",
          "throw"
        ],
        "example": "try {\n    throw std::overflow_error(\"too big\");\n} catch (const std::exception& e) {\n    throw; // overflow_error\n}"
      }
    ]
  },
  {
    "keyword": "true",
    "usage": [
      {
        "info": "ç”¨äºæ•°æ®æˆåˆ†ï¼šè¡¨ç¤ºçœŸçš„å¸ƒå°”ç±»å‹å­—é¢å€¼ã€‚",
        "sdsc": [
          "true"
        ],
        "example": "bool flag = true;"
      }
    ]
  },
  {
    "keyword": "try",
    "usage": [
      {
        "info": "ç”¨äºå¼‚å¸¸å¤„ç†ï¼šå…³è”ä¸€ä¸ªå¤åˆè¯­å¥ä½¿å¾—å…¶ä¸­çš„å¼‚å¸¸å¯ä»¥è¢«å¤„ç†ã€‚",
        "sdsc": [
          "try <i>å¤åˆè¯­å¥</i>\ncatch (<x-or><i>å£°æ˜åºåˆ—</i><hr>...</x-or>) <i>å¤åˆè¯­å¥</i>"
        ],
        "example": "try {\n    str.substr(10);\n} catch (std::exception e) {\n    std::cerr << e.what();\n}"
      }
    ]
  },
  {
    "keyword": "typedef",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šåˆ›å»ºæ›¿ä»£ç±»å‹åçš„åˆ«åï¼Œä½†ä¸èƒ½æ˜¯æ¨¡æ¿åã€‚æ­¤å£°æ˜å°†å£°æ˜ç¬¦çš„åå­—ä½œä¸ºç±»å‹çš„åˆ«åã€‚",
        "sdsc": [
          "typedef <i>ç±»å‹å</i> <i>å£°æ˜ç¬¦</i>"
        ],
        "example": "typedef unsigned int uint;\ntypedef int arr10OfInt[10];\ntypedef void (*ptr2Func)();"
      }
    ]
  },
  {
    "keyword": "typeid",
    "usage": [
      {
        "info": "\n            ç”¨äºè¿ç®—ç¬¦ï¼šæŸ¥è¯¢ç±»å‹çš„ä¿¡æ¯ï¼Œæˆ–è€…æ“ä½œæ•°çš„ç±»å‹çš„ä¿¡æ¯ï¼Œè¿”å›std::type_infoå¯¹è±¡ï¼Œå¯ä»¥é€šè¿‡name()æˆå‘˜å‡½æ•°è·å–ç±»å‹åã€‚å¯¹äºéƒ¨åˆ†ç¼–è¯‘ç¯å¢ƒï¼Œæ­¤ç»“æœå¯èƒ½éœ€è¦c++filtè¿›è¡Œè½¬è¯‘ã€‚",
        "sdsc": [
          "typeid(<i>ç±»å‹</i>)",
          "typeid(<i>è¡¨è¾¾å¼</i>)"
        ],
        "example": "#include <typeinfo> // must\nstruct Base {\n    virtual ~Base() {}\n};\nstruct Derived : Base {};\nint main() {\n    Base* ptr = new Derived;\n    typeid(*ptr).name(); // Derived or 7Derived or sth else\n    typeid(int* (*)()).name();// int* (*)* or PFPivE or sth else\n}"
      }
    ]
  },
  {
    "keyword": "typename",
    "usage": [
      {
        "info": "1. ç”¨äºæ¨¡æ¿ï¼šåœ¨æ¨¡æ¿å£°æ˜ä¸­ç”¨ä»¥å¼•å…¥ç±»å‹æ¨¡æ¿å½¢å‚ï¼Œä¸classç­‰ä»·ã€‚",
        "sdsc": [
          "template &lt;<x-or>class<hr>typename</x-or> <b>ç±»å‹å½¢å‚</b>&gt;\n<i>å£°æ˜</i>"
        ],
        "example": "template <typename T>\nT& max(const T& a,const T& b) {\n    return a > b ? a : b;\n}"
      },
      {
        "info": "2. ç”¨äºæ¨¡æ¿ï¼šåœ¨æ¨¡æ¿å£°æ˜ä¸­æŒ‡æ˜æŸä¸ªå¾…å†³åä¸ºç±»å‹ï¼Œä»¥åŒºåˆ«äºé™æ€æˆå‘˜å˜é‡ï¼Œé˜²æ­¢ç¼–è¯‘é”™è¯¯ã€‚",
        "sdsc": [
          "typename <i>å¾…å†³åä½™ä¸‹å£°æ˜</i>;"
        ],
        "example": "template<typename T>\nvoid f(T t) {\n    typename T::iterator iter;\n    iter = t.begin();\n}"
      },
      {
        "info": "3. ç”¨äºæ¦‚å¿µï¼šåœ¨ requires è¡¨è¾¾å¼çš„è¦æ±‚ä¸­ï¼Œç”¨äºæ ¡éªŒç±»å‹åæ˜¯å¦åˆæ³•ã€‚",
        "sdsc": [
          "typename <i>ç±»å‹å</i>"
        ],
        "example": "template<typename T>\nconcept HaveInner =\nrequires {\n    typename T::inner;\n};"
      }
    ]
  },
  {
    "keyword": "union",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šå£°æ˜è”åˆä½“ï¼Œå³ä¸€ä¸ªæ—¶åˆ»åªèƒ½ä¿æœ‰ä¸€ä¸ªéé™æ€æ•°æ®æˆå‘˜çš„ç±»å‹ã€‚",
        "sdsc": [
          "union <b>è”åˆä½“å</b> { <b>æˆå‘˜åˆ—è¡¨</b> };"
        ],
        "example": "union ID {\n    int no;\n    char name[32];\n};"
      }
    ]
  },
  {
    "keyword": "unsigned",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šåŸºç¡€æ— ç¬¦å·æ•´æ•°ç±»å‹çš„ç±»å‹è¯´æ˜ç¬¦ï¼Œæˆ–è€…ä½œä¸ºå…¶ä»–æ— ç¬¦å·æ•´å‹å˜é‡çš„ç±»å‹è¯´æ˜ç¬¦çš„éƒ¨åˆ†ã€‚",
        "sdsc": [
          "unsigned <i>å˜é‡å</i> <b>åˆå§‹åŒ–å™¨</b>;"
        ],
        "example": "unsigned score = 60;"
      }
    ]
  },
  {
    "keyword": "using",
    "usage": [
      {
        "info": "1. ç”¨äºå‘½åç©ºé—´ï¼šå¼•å…¥å‘½åç©ºé—´æˆ–è€…å‘½åç©ºé—´ä¸­çš„å¯¹è±¡ã€‚",
        "sdsc": [
          "using namespace <i>å‘½åç©ºé—´å</i>;",
          "using <i>å¯¹è±¡å</i>;"
        ],
        "example": "using namespace std;\nusing std::cin;\nusing std::cout;"
      },
      {
        "info": "2. ç”¨äºå£°æ˜ï¼šç”¨äºåˆ›å»ºæŒ‡ä»£ç±»å‹åçš„åˆ«åï¼Œä¸typedefç±»ä¼¼ã€‚äº¦å¯ä»¥åˆ›å»ºåˆ«åæ¨¡æ¿ã€‚",
        "sdsc": [
          "using <i>åˆ«å</i> = <i>ç±»å‹æ ‡è¯†</i>;",
          "template&lt;<i>å½¢å‚åˆ—è¡¨</i>&gt;\nusing <i>åˆ«å</i> = <i>ç±»å‹æ ‡è¯†</i>;"
        ],
        "example": "using uint = usigned int;\nusing array10OfInt = int[10];\nusing ptr2Func = void (*)();\ntemplate<typename T>\nusing Ptr = T*;"
      }
    ]
  },
  {
    "keyword": "virtual",
    "usage": [
      {
        "info": "1. ç”¨äºé¢å‘å¯¹è±¡ï¼šå£°æ˜æˆå‘˜å‡½æ•°ä¸ºè™šå‡½æ•°ï¼Œå³åœ¨å¤šæ€åœºæ™¯ä¸‹ï¼Œå…¶å¯ä»¥è¢«å­ç±»æˆå‘˜åŒåå‡½æ•°æ‰€è¦†ç›–ã€‚äº¦å¯å£°æ˜ä¸ºçº¯è™šå‡½æ•°ï¼Œåˆ™è¯¥ç±»æˆä¸ºæŠ½è±¡ç±»ä¸”ä¸å¾—æœ‰å®ä¾‹ã€‚",
        "sdsc": [
          "virtual <b>è¿”å›ç±»å‹</b> <i>å‡½æ•°å</i>(<b>å½¢å‚åˆ—è¡¨</b>);",
          "virtual <b>è¿”å›ç±»å‹</b> <i>å‡½æ•°å</i>(<b>å½¢å‚åˆ—è¡¨</b>) = 0;"
        ],
        "example": "struct Base {\n    virtual void f() {std::cout << \"Base Func\n  Called\";\n    }\n};\nstruct Derived : public Base {\n    void f() {std::cout << \"Derived\n  Called\";\n    }\n};\nint main() {\n    Base* b = new Derived;\n    b->f(); // Derived Called\n}"
      },
      {
        "info": "2. ç”¨äºé¢å‘å¯¹è±¡ï¼šå£°æ˜ç»§æ‰¿æ–¹å¼ä¸ºè™šç»§æ‰¿ï¼Œå³åœ¨å¤šé‡ç»§æ‰¿ä¸­ï¼Œæœ€ç»ˆæ´¾ç”Ÿå¯¹è±¡åªæœ‰ä¸€ä¸ªåŸºç±»æˆå‘˜ã€‚",
        "sdsc": [
          "<x-or>class<hr>struct</x-or> <b>ç±»å</b> : virtual <opt-block><x-or>private<hr>protected<hr>public</x-or></opt-block> <i>çˆ¶ç±»å</i> {\n    <b>æˆå‘˜åˆ—è¡¨</b> \n};"
        ],
        "example": "struct A {\n    int n;\n};\nstruct B : virtual public A {};\nstruct C : virtual public A {};\nstruct D : B,C {\n    void f() {\n        n;\n        B::n;\n        C::n; // same\n    }\n};"
      }
    ]
  },
  {
    "keyword": "void",
    "usage": [
      {
        "info": "1. ç”¨äºå£°æ˜ï¼šç©ºç±»å‹çš„ç±»å‹è¯´æ˜ç¬¦ã€‚ç©ºç±»å‹æ˜¯å€¼çš„é›†åˆä¸ºç©ºé›†çš„ç±»å‹ï¼Œä¸å­˜åœ¨ç©ºç±»å‹çš„å¯¹è±¡ï¼Œä½†å­˜åœ¨æŒ‡å‘ç©ºç±»å‹çš„æŒ‡é’ˆå’Œè¿”å›ç©ºç±»å‹çš„å‡½æ•°ã€‚",
        "sdsc": [
          "void* <i>æŒ‡é’ˆå</i>;",
          "void <i>å‡½æ•°å</i>(<b>å½¢å‚åˆ—è¡¨</b>);"
        ],
        "example": "void f() {   \n    int a{42};\n    void* pa{reinterpret_cast<void*>(&a)};\n}"
      }
    ]
  },
  {
    "keyword": "volatile",
    "usage": [
      {
        "info": "1. ç”¨äºå£°æ˜ï¼šå£°æ˜è¯¥å˜é‡åªä¸ºæ˜“å˜çš„ï¼Œå³å®ƒçš„å€¼å¯èƒ½ä¼šä»¥æŸäº›ä¸å¯æ£€æµ‹çš„æ–¹å¼å‘ç”Ÿæ”¹å˜ã€‚å› æ­¤æ­¤ç±»å˜é‡æ¯æ¬¡ä¿®æ”¹å°†è¯»å†™å†…å­˜è€Œéå¯„å­˜å™¨ï¼Œä¸”é¿å…ç¼–è¯‘å™¨è¿›è¡Œä¼˜åŒ–ã€‚",
        "sdsc": [
          "volatile <i>ç±»å‹è¯´æ˜ç¬¦</i> <i>å˜é‡å</i> <b>åˆå§‹åŒ–å™¨</b>;"
        ],
        "example": "volatile double result{2.56};"
      },
      {
        "info": "2. ç”¨äºå£°æ˜ï¼šå£°æ˜æˆå‘˜å‡½æ•°ä¸ºæ˜“å˜çš„ï¼Œå³å®ƒæ‰€è®¿é—®çš„æˆå‘˜çš„å€¼å¯èƒ½ä¼šä»¥æŸäº›ä¸å¯æ£€æµ‹çš„æ–¹å¼å‘ç”Ÿæ”¹å˜ã€‚",
        "sdsc": [
          "<i>è¿”å›ç±»å‹</i> <i>å‡½æ•°å</i>(<b>å½¢å‚åˆ—è¡¨</b>) volatile;"
        ],
        "example": "struct S {\n    void f() volatile {}\n};"
      }
    ]
  },
  {
    "keyword": "wchar_t",
    "usage": [
      {
        "info": "ç”¨äºå£°æ˜ï¼šå®½å­—ç¬¦ç±»å‹å˜é‡çš„ç±»å‹è¯´æ˜ç¬¦ã€‚å®½å­—ç¬¦ç±»å‹æ˜¯é•¿åº¦è¶³å¤Ÿè¡¨ç¤ºå½“å‰ç¯å¢ƒä»»ä½•å¯ç¼–ç å­—ç¬¦çš„ç±»å‹ã€‚åœ¨Linuxä¸­ï¼Œä¸€èˆ¬ä¸º32ä½é•¿åº¦ï¼Œä½†åœ¨Windowsä¸­ä¸º16ä½é•¿åº¦ã€‚",
        "sdsc": [
          "wchar_t <i>å˜é‡å</i> <b>åˆå§‹åŒ–å™¨</b>;"
        ],
        "example": "wchar_t hanzi = L'å­—';"
      }
    ]
  },
  {
    "keyword": "while",
    "usage": [
      {
        "info": "ç”¨äºæ§åˆ¶æˆåˆ†ï¼šå½¢æˆwhileå¾ªç¯ã€‚",
        "sdsc": [
          "while (<i>æ¡ä»¶</i>)\n    <i>è¯­å¥</i>"
        ],
        "example": "int i = 0;\nwhile (i < 10) {\n    i++;\n}"
      }
    ]
  },
  {
    "keyword": "xor",
    "usage": [
      {
        "info": "ç”¨äºè¿ç®—ç¬¦ï¼š<code>^</code>çš„æ›¿ä»£å†™æ³•ã€‚",
        "sdsc": [
          "<i>å·¦ä¾§æ“ä½œæ•°</i> xor <i>å³ä¾§æ“ä½œæ•°</i>"
        ],
        "example": "a xor b;"
      }
    ]
  },
  {
    "keyword": "xor_eq",
    "usage": [
      {
        "info": "ç”¨äºè¿ç®—ç¬¦ï¼š<code>^=</code>çš„æ›¿ä»£å†™æ³•ã€‚",
        "sdsc": [
          "<i>å·¦ä¾§æ“ä½œæ•°</i> xor_eq <i>å³ä¾§æ“ä½œæ•°</i>"
        ],
        "example": "flag xor_eq true;"
      }
    ]
  }
]